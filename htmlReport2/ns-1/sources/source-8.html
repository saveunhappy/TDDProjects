


<!DOCTYPE html>
<html id="htmlId">
<head>
  <title>Coverage Report > InjectionProvider</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">com.geektime.tdd</a>
</div>

<h1>Coverage Summary for Class: InjectionProvider (com.geektime.tdd)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">InjectionProvider</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (13/13)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    95.8%
  </span>
  <span class="absValue">
    (46/48)
  </span>
</td>
</tr>
  <tr>
    <td class="name">InjectionProvider$Injectable</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (7/7)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (10/10)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (20/20)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    96.6%
  </span>
  <span class="absValue">
    (56/58)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;package com.geektime.tdd;
&nbsp;
&nbsp;import jakarta.inject.Inject;
&nbsp;import jakarta.inject.Qualifier;
&nbsp;
&nbsp;import java.lang.annotation.Annotation;
&nbsp;import java.lang.reflect.*;
&nbsp;import java.util.*;
&nbsp;import java.util.function.BiFunction;
&nbsp;import java.util.stream.Stream;
&nbsp;
&nbsp;import static java.util.Arrays.stream;
&nbsp;import static java.util.stream.Stream.concat;
&nbsp;
&nbsp;class InjectionProvider&lt;T&gt; implements ComponentProvider&lt;T&gt; {
&nbsp;
&nbsp;    private Injectable&lt;Constructor&lt;T&gt;&gt; injectConstructor;
&nbsp;    private List&lt;Injectable&lt;Method&gt;&gt; injectMethods;
&nbsp;    private List&lt;Injectable&lt;Field&gt;&gt; injectFields;
&nbsp;
<b class="fc">&nbsp;    public InjectionProvider(Class&lt;T&gt; component) {</b>
<b class="fc">&nbsp;        if (Modifier.isAbstract(component.getModifiers())) throw new IllegalComponentException();</b>
<b class="fc">&nbsp;        this.injectConstructor = getInjectConstructor(component);</b>
&nbsp;        //因为方法和字段都是有多个的，方法有多个，但是getInjectable是接受一个Constructor或者是Method或者是Field，
&nbsp;        //所以是先获取方法，方法有多个，所以通过stream的方式去取，一个一个的获取到依赖
<b class="fc">&nbsp;        this.injectMethods = getInjectMethods(component);</b>
<b class="fc">&nbsp;        this.injectFields = getInjectField(component);</b>
&nbsp;
<b class="fc">&nbsp;        if (injectFields.stream().map(Injectable::element).anyMatch(f -&gt; Modifier.isFinal(f.getModifiers())))</b>
<b class="fc">&nbsp;            throw new IllegalComponentException();</b>
&nbsp;        //这里本来是injectMethods进行stream，就是看那个方法签名上有泛型，但是现在封装成对象了中的属性了，就是element,
&nbsp;        // element就是Constructor,Method,Field，那没关系，我们在经过map转换成原来的Constructor,Method,Field，就好了
<b class="fc">&nbsp;        if (injectMethods.stream().map(Injectable::element).anyMatch(m -&gt; m.getTypeParameters().length != 0))</b>
<b class="fc">&nbsp;            throw new IllegalComponentException();</b>
&nbsp;        //为什么需要这行代码？因为我们在创建对象的时候，有依赖，构造函数的依赖如果有俩注解，@Named(&quot;ChosenOne&quot;)@Skywalker
&nbsp;        //这个样子是不允许的，你可以bind多个，但是我们查找的时候只能有一个，所以在查找dependency的时候就会报错，这个就是冗余了
&nbsp;        //因为在创建对象的时候获取了一遍，然后在创建对象的时候又获取了一遍，这个是冗余的，所以才要建模
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public T get(Context context) {
&nbsp;        try {
<b class="fc">&nbsp;            T instance = injectConstructor.element().newInstance(injectConstructor.toDependencies(context));</b>
<b class="fc">&nbsp;            for (Injectable&lt;Field&gt; field : injectFields) {</b>
<b class="fc">&nbsp;                field.element().set(instance, field.toDependencies(context)[0]);</b>
<b class="fc">&nbsp;            }</b>
<b class="fc">&nbsp;            for (Injectable&lt;Method&gt; method : injectMethods) {</b>
&nbsp;                //和上面一样，既然变成对象了，那么就变成对象的属性调用，然后获取依赖，已经封装进对象中去了，所以这边可以这样改
<b class="fc">&nbsp;                method.element().invoke(instance, method.toDependencies(context));</b>
<b class="fc">&nbsp;            }</b>
<b class="fc">&nbsp;            return instance;</b>
<b class="nc">&nbsp;        } catch (InvocationTargetException | InstantiationException | IllegalAccessException e) {</b>
<b class="nc">&nbsp;            throw new RuntimeException(e);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public List&lt;ComponentRef&lt;?&gt;&gt; getDependencies() {
&nbsp;        //injectConstructor是单个的，变成stream，然后后面的就都取stream，因为后面俩是List，然后都取进行flatMap
&nbsp;        //然后把所有的依赖都再组合成stream,在变成toList();
<b class="fc">&nbsp;        return concat(concat(Stream.of(injectConstructor), injectMethods.stream()), injectFields.stream())</b>
<b class="fc">&nbsp;                .flatMap(i -&gt; stream(i.require())).toList();</b>
&nbsp;    }
&nbsp;
<b class="fc">&nbsp;    record Injectable&lt;Element extends AccessibleObject&gt;(Element element, ComponentRef&lt;?&gt;[] require) {</b>
&nbsp;        static &lt;Element extends Executable&gt; Injectable&lt;Element&gt; of(Element injectable) {
<b class="fc">&nbsp;            return new Injectable&lt;&gt;(injectable, stream(injectable.getParameters()).map(Injectable::toComponentRef).toArray(ComponentRef&lt;?&gt;[]::new));</b>
&nbsp;        }
&nbsp;
&nbsp;        //构造器，有多个参数，方法，有多个参数，但是你属性，你就只有你本身，所一就是一个
&nbsp;        static Injectable&lt;Field&gt; of(Field field) {
<b class="fc">&nbsp;            return new Injectable&lt;&gt;(field, new ComponentRef&lt;?&gt;[]{toComponentRef(field)});</b>
&nbsp;        }
&nbsp;
&nbsp;        Object[] toDependencies(Context context) {
<b class="fc">&nbsp;            return stream(require).map(context::get).map(Optional::get).toArray();</b>
&nbsp;        }
&nbsp;
&nbsp;        private static ComponentRef toComponentRef(Field field) {
<b class="fc">&nbsp;            return ComponentRef.of(field.getGenericType(), getQualifier(field));</b>
&nbsp;        }
&nbsp;
&nbsp;        private static ComponentRef&lt;?&gt; toComponentRef(Parameter parameter) {
<b class="fc">&nbsp;            return ComponentRef.of(parameter.getParameterizedType(), getQualifier(parameter));</b>
&nbsp;        }
&nbsp;
&nbsp;        private static Annotation getQualifier(AnnotatedElement field) {
<b class="fc">&nbsp;            List&lt;Annotation&gt; qualifiers = stream(field.getAnnotations())</b>
<b class="fc">&nbsp;                    .filter(a -&gt; a.annotationType().isAnnotationPresent(Qualifier.class)).toList();</b>
<b class="fc">&nbsp;            if (qualifiers.size() &gt; 1) throw new IllegalComponentException();</b>
<b class="fc">&nbsp;            return qualifiers.stream().findFirst().orElse(null);</b>
&nbsp;        }
&nbsp;
&nbsp;    }
&nbsp;
&nbsp;    private static &lt;T&gt; Injectable&lt;Constructor&lt;T&gt;&gt; getInjectConstructor(Class&lt;T&gt; component) {
<b class="fc">&nbsp;        List&lt;Constructor&lt;?&gt;&gt; injectConstructors = injectable(component.getConstructors()).toList();</b>
<b class="fc">&nbsp;        if (injectConstructors.size() &gt; 1) throw new IllegalComponentException();</b>
&nbsp;        //找不到被@Inject标注的，并且找不到默认的构造函数
<b class="fc">&nbsp;        return Injectable.of((Constructor&lt;T&gt;) injectConstructors</b>
<b class="fc">&nbsp;                .stream().findFirst().orElseGet(() -&gt; defaultConstructor(component)));</b>
&nbsp;    }
&nbsp;
&nbsp;    private static List&lt;Injectable&lt;Field&gt;&gt; getInjectField(Class&lt;?&gt; component) {
<b class="fc">&nbsp;        List&lt;Field&gt; injectField = traverse(component, (fields, current) -&gt; injectable(current.getDeclaredFields()).toList());</b>
<b class="fc">&nbsp;        return injectField.stream().map(Injectable::of).toList();</b>
&nbsp;    }
&nbsp;
&nbsp;    private static List&lt;Injectable&lt;Method&gt;&gt; getInjectMethods(Class&lt;?&gt; component) {
<b class="fc">&nbsp;        List&lt;Method&gt; injectMethods = traverse(component, (methods, current) -&gt; injectable(current.getDeclaredMethods())</b>
<b class="fc">&nbsp;                .filter(m -&gt; isOverrideByInjectMethod(methods, m))</b>
&nbsp;                //这个Component就是你去调用这个Component的方法，他的install方法没有标注@Inject，所以没有标注进来
&nbsp;                //但是一直在网上找，如果没有这句代码，标注了@Inject的install方法就被放进来了，但是你不应该放进来
&nbsp;                //所以如果你发现你的install方法标注了@Inject，你的子类没有标注，那就去掉它
<b class="fc">&nbsp;                .filter(m -&gt; isOverrideByNoInjectMethod(component, m))</b>
<b class="fc">&nbsp;                .toList());</b>
<b class="fc">&nbsp;        Collections.reverse(injectMethods);</b>
<b class="fc">&nbsp;        return injectMethods.stream().map(Injectable::of).toList();</b>
&nbsp;    }
&nbsp;
&nbsp;    private static &lt;T&gt; List&lt;T&gt; traverse(Class&lt;?&gt; component, BiFunction&lt;List&lt;T&gt;, Class&lt;?&gt;, List&lt;T&gt;&gt; finder) {
<b class="fc">&nbsp;        List&lt;T&gt; members = new ArrayList&lt;&gt;();</b>
<b class="fc">&nbsp;        Class&lt;?&gt; current = component;</b>
<b class="fc">&nbsp;        while (current != Object.class) {</b>
<b class="fc">&nbsp;            members.addAll(finder.apply(members, current));</b>
<b class="fc">&nbsp;            current = current.getSuperclass();</b>
&nbsp;        }
<b class="fc">&nbsp;        return members;</b>
&nbsp;    }
&nbsp;
&nbsp;    private static &lt;Type&gt; Constructor&lt;Type&gt; defaultConstructor(Class&lt;Type&gt; implementation) {
&nbsp;        try {
<b class="fc">&nbsp;            return implementation.getDeclaredConstructor();</b>
<b class="fc">&nbsp;        } catch (NoSuchMethodException e) {</b>
&nbsp;            //这里之前是RuntimeException，改成我们的自定义异常了
<b class="fc">&nbsp;            throw new IllegalComponentException();</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    private static &lt;T extends AnnotatedElement&gt; Stream&lt;T&gt; injectable(T[] declaredFields) {
<b class="fc">&nbsp;        return stream(declaredFields).filter(f -&gt; f.isAnnotationPresent(Inject.class));</b>
&nbsp;    }
&nbsp;
&nbsp;    private static boolean isOverride(Method m, Method o) {
<b class="fc">&nbsp;        return o.getName().equals(m.getName()) &amp;&amp; Arrays.equals(o.getParameterTypes(), m.getParameterTypes());</b>
&nbsp;    }
&nbsp;
&nbsp;    private static &lt;T&gt; boolean isOverrideByNoInjectMethod(Class&lt;T&gt; component, Method m) {
<b class="fc">&nbsp;        return stream(component.getDeclaredMethods()).</b>
<b class="fc">&nbsp;                filter(m1 -&gt; !m1.isAnnotationPresent(Inject.class))</b>
<b class="fc">&nbsp;                .noneMatch(o -&gt; isOverride(m, o));</b>
&nbsp;    }
&nbsp;
&nbsp;    private static boolean isOverrideByInjectMethod(List&lt;Method&gt; injectMethods, Method m) {
<b class="fc">&nbsp;        return injectMethods.stream().noneMatch(o -&gt; isOverride(m, o));</b>
&nbsp;    }
&nbsp;
&nbsp;
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2023-12-23 03:48</div>
</div>
</body>
</html>
